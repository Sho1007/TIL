# 9465 스티커 (c++)

## 문제
https://www.acmicpc.net/problem/9465

## 접근 방식
DP
1. 지그재그로 더해봄
2. 한칸 건너 뛰고 더해야한다는걸 깨달음
3. 현재칸 + 두칸전 dp (만약 같은 행이라면 + 한칸전 대각선 값 (지그재그 성립하기 때문))
	*	```c++
			// 여기서 300이 나와야하는데 202가 나옴
			// 현재칸을 포기하는 방법을 포함시키지 않았기 때문
			1
			4
			100     1      1     100
			1       1      100      1
		```
4. max(현재칸 + 한칸전 대각선 dp, 한칸전 같은열 dp) -> 여기서 성공
	* 굳이 두칸전과 한칸전 두개를 다 살펴볼 필요가 없었다.
	* 현재값을 포기하고 한칸전 같은열 dp를 취할지, 현재값 + 대각선 한칸전 dp를 취할지만 고르면 되는 문제였음
5. 맞춘 사람들 보니 메모리와 시간을 압도적으로 적게 썼음 -> 최적화 시작
	1. 우선 vector를 썼던걸 arr로 바꿈
		* 이전엔 clear를 했었는데 어차피 새 값으로 덮어지기때문에 굳이 그럴 필요가 없었음
	2. (메모리 4628KB -> 3584KB) (시간 304ms -> 88ms)
	3. dp가 앞의 한줄만 필요했기때문에 [2][2] 배열을 선언해서 1열은 이전값으로 2열은 현재값으로 사용 후 한칸식 앞으로 밀어줬음
	4. (메모리 3584KB -> 2800KB)
6. 여기서 만족할 수 있었으나 메모리 천KB대의 사람들을 따라잡고 싶어짐
	1. 입력에서 배열을 한 행씩 주기때문에 처음엔 배열을 다 받고 다음에 다시 처음부터 계산을 시작했었음
	2. 생각해보니 한 행을 다 받고나면 다음 행에선 받자마자 해당 열까지의 계산이 가능한게 아닌가 생각이 듦
	3. 2행은 필요 없고 1행을 다 받은 뒤 다시 N+1(0안쓰고 1~N만큼 그대로 쓰기 위해서)만큼 반복하면서 num에 입력받아서 사용함
	4. (메모리 2800KB -> 2412KB) (시간 84ms -> 80ms)
	5. 혹시 미리 최대값만큼 배열을 만들어놔서 그런게 아닌가 싶어서 포인트로 그때그때 new int, delete 를 해봄
	6. (메모리 2412KB -> 2776KB) (시간 80ms -> 84ms)
	7. 할당하고 지우고 해서 계속 다른 부분을 사용하다보니 한번 할당 후 그 부분만 쓰던거보다 메모리 사용량이 늘어남 
		* 할당, 해제 시간때문에 같은 이유로 시간도 늘어남
7. 2412KB, 80ms 로 만족해야할 것 같음

## 문제 풀이
```c++
#include <iostream>
#include <algorithm>

#define endl "\n"

using namespace std;

int T, N = -1;

int arr[100'001] = {};
int dp[2][2] = {};


int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> T;

	int num;

	while (T-- > 0)
	{
		cin >> N;

		for (int j = 1; j <= N; ++j)
		{
			cin >> arr[j];
		}

		cin >> num;

		dp[0][1] = arr[1];
		dp[1][1] = num;

		for (int j = 2; j <= N; ++j)
		{
			dp[0][0] = dp[0][1];
			dp[1][0] = dp[1][1];

			cin >> num;

			dp[0][1] = max(arr[j] + dp[1][0], dp[0][0]);
			dp[1][1] = max(num + dp[0][0], dp[1][0]);
		}

		cout << max(dp[0][1], dp[1][1]) << endl;
	}

	return 0;
}
```
1. N 입력받고 배열이 1행 숫자 입력
2. num 에 2행 1열 숫자 입력 받고 dp 세팅
3. 2부터 N번까지 반복
	* dp 한칸 앞으로 밀어주기
	* 2행 j열에 해당하는 숫자 num에 받기
	* max(한칸전 대각선 dp값 + 현재칸 값, 한칸전 동일행 dp값) 을 현재칸 dp에 넣어주기
4. max(dp[0][1], dp[1][1]) 출력


## 다시 생각해볼 점
dp 문제는 항상 하위 문제를 어떻게 구성할것이냐가 중요한 것 같다.   
이번 문제도 현재값을 항상 포함시킨다고 생각하니 두칸전 dp와 한칸전 대각선 값까지 생각해야하는 복잡한 계산이 필요했다. (답도 틀림)   
현재값을 포함한다면? 포함하지 않는다면? 으로 나눠서 생각해야   
현재값 + 대각선 dp, 한칸전 dp 로 간단하게 나눠떨어진다.